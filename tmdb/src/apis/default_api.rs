/*
 * TMDB API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`account_add_favorite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAddFavoriteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_add_to_watchlist`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAddToWatchlistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_favorite_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountFavoriteTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_get_favorites`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountGetFavoritesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_lists`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountListsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_rated_movies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountRatedMoviesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_rated_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountRatedTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_rated_tv_episodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountRatedTvEpisodesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_watchlist_movies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountWatchlistMoviesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_watchlist_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountWatchlistTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`alternative_names_copy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlternativeNamesCopyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_create_guest_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationCreateGuestSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_create_request_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationCreateRequestTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_create_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationCreateSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_create_session_from_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationCreateSessionFromLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_create_session_from_v4_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationCreateSessionFromV4TokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_delete_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationDeleteSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authentication_validate_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationValidateKeyError {
    Status401(models::AuthenticationValidateKey401Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`certification_movie_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CertificationMovieListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`certifications_tv_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CertificationsTvListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`changes_movie_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangesMovieListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`changes_people_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangesPeopleListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`changes_tv_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangesTvListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`collection_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CollectionDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`collection_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CollectionImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`collection_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CollectionTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_alternative_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAlternativeNamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_countries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationCountriesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_jobs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationJobsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_languages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationLanguagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_primary_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationPrimaryTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_timezones`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationTimezonesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`credit_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreditDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`details_copy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DetailsCopyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discover_movie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoverMovieError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discover_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoverTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`genre_movie_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenreMovieListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`genre_tv_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenreTvListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`guest_session_rated_movies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GuestSessionRatedMoviesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`guest_session_rated_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GuestSessionRatedTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`guest_session_rated_tv_episodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GuestSessionRatedTvEpisodesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keyword_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeywordDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keyword_movies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeywordMoviesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_add_movie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAddMovieError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_check_item_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCheckItemStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_clear`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListClearError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_remove_movie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRemoveMovieError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lists_copy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListsCopyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_account_states`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieAccountStatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_add_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieAddRatingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_alternative_titles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieAlternativeTitlesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_changes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieChangesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_delete_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieDeleteRatingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_external_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieExternalIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_keywords`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieKeywordsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_latest_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieLatestIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_lists`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieListsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_now_playing_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieNowPlayingListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_popular_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoviePopularListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_recommendations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieRecommendationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_release_dates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieReleaseDatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_reviews`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieReviewsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_similar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieSimilarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_top_rated_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieTopRatedListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_upcoming_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieUpcomingListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_videos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieVideosError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`movie_watch_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MovieWatchProvidersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_changes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonChangesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_combined_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonCombinedCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_external_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonExternalIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_latest_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonLatestIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_movie_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonMovieCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_popular_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonPopularListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_tagged_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonTaggedImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`person_tv_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersonTvCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`review_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReviewDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCollectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_company`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCompanyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_keyword`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchKeywordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_movie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchMovieError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_multi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchMultiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_person`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchPersonError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trending_all`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrendingAllError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trending_movies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrendingMoviesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trending_people`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrendingPeopleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trending_tv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrendingTvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_account_states`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeAccountStatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_add_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeAddRatingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_changes_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeChangesByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_delete_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeDeleteRatingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_external_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeExternalIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_group_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeGroupDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_episode_videos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvEpisodeVideosError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_account_states`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonAccountStatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_aggregate_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonAggregateCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_changes_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonChangesByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_external_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonExternalIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_videos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonVideosError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_season_watch_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeasonWatchProvidersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_account_states`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesAccountStatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_add_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesAddRatingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_aggregate_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesAggregateCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_airing_today_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesAiringTodayListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_alternative_titles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesAlternativeTitlesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_changes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesChangesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_content_ratings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesContentRatingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_credits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesCreditsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_delete_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesDeleteRatingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_episode_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesEpisodeGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_external_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesExternalIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_keywords`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesKeywordsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_latest_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesLatestIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_on_the_air_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesOnTheAirListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_popular_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesPopularListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_recommendations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesRecommendationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_reviews`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesReviewsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_screened_theatrically`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesScreenedTheatricallyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_similar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesSimilarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_top_rated_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesTopRatedListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_videos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesVideosError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tv_series_watch_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TvSeriesWatchProvidersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`watch_provider_tv_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WatchProviderTvListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`watch_providers_available_regions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WatchProvidersAvailableRegionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`watch_providers_movie_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WatchProvidersMovieListError {
    UnknownValue(serde_json::Value),
}


/// Mark a movie or TV show as a favourite.
pub async fn account_add_favorite(configuration: &configuration::Configuration, account_id: i32, session_id: Option<&str>, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::MovieAddRating200Response, Error<AccountAddFavoriteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/account/{account_id}/favorite", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAddRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAddRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountAddFavoriteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a movie or TV show to your watchlist.
pub async fn account_add_to_watchlist(configuration: &configuration::Configuration, account_id: i32, session_id: Option<&str>, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::MovieAddRating200Response, Error<AccountAddToWatchlistError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/account/{account_id}/watchlist", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAddRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAddRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountAddToWatchlistError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the public details of an account on TMDB.
pub async fn account_details(configuration: &configuration::Configuration, account_id: i32, session_id: Option<&str>) -> Result<models::AccountDetails200Response, Error<AccountDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_session_id = session_id;

    let uri_str = format!("{}/3/account/{account_id}", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a users list of favourite TV shows.
pub async fn account_favorite_tv(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountFavoriteTv200Response, Error<AccountFavoriteTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/favorite/tv", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountFavoriteTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountFavoriteTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountFavoriteTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a users list of favourite movies.
pub async fn account_get_favorites(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountGetFavorites200Response, Error<AccountGetFavoritesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/favorite/movies", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountGetFavorites200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountGetFavorites200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountGetFavoritesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a users list of custom lists.
pub async fn account_lists(configuration: &configuration::Configuration, account_id: i32, page: Option<i32>, session_id: Option<&str>) -> Result<models::AccountLists200Response, Error<AccountListsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_page = page;
    let p_session_id = session_id;

    let uri_str = format!("{}/3/account/{account_id}/lists", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountLists200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountLists200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountListsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a users list of rated movies.
pub async fn account_rated_movies(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountRatedMovies200Response, Error<AccountRatedMoviesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/rated/movies", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountRatedMovies200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountRatedMovies200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountRatedMoviesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a users list of rated TV shows.
pub async fn account_rated_tv(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountRatedTv200Response, Error<AccountRatedTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/rated/tv", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountRatedTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountRatedTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountRatedTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a users list of rated TV episodes.
pub async fn account_rated_tv_episodes(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountRatedTvEpisodes200Response, Error<AccountRatedTvEpisodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/rated/tv/episodes", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountRatedTvEpisodes200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountRatedTvEpisodes200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountRatedTvEpisodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of movies added to a users watchlist.
pub async fn account_watchlist_movies(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountWatchlistMovies200Response, Error<AccountWatchlistMoviesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/watchlist/movies", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountWatchlistMovies200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountWatchlistMovies200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountWatchlistMoviesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of TV shows added to a users watchlist.
pub async fn account_watchlist_tv(configuration: &configuration::Configuration, account_id: i32, language: Option<&str>, page: Option<i32>, session_id: Option<&str>, sort_by: Option<&str>) -> Result<models::AccountWatchlistTv200Response, Error<AccountWatchlistTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_language = language;
    let p_page = page;
    let p_session_id = session_id;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/account/{account_id}/watchlist/tv", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountWatchlistTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountWatchlistTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountWatchlistTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the TV network logos by id.
pub async fn alternative_names_copy(configuration: &configuration::Configuration, network_id: i32) -> Result<models::AlternativeNamesCopy200Response, Error<AlternativeNamesCopyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_network_id = network_id;

    let uri_str = format!("{}/3/network/{network_id}/images", configuration.base_path, network_id=p_network_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlternativeNamesCopy200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlternativeNamesCopy200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AlternativeNamesCopyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn authentication_create_guest_session(configuration: &configuration::Configuration, ) -> Result<models::AuthenticationCreateGuestSession200Response, Error<AuthenticationCreateGuestSessionError>> {

    let uri_str = format!("{}/3/authentication/guest_session/new", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationCreateGuestSession200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationCreateGuestSession200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationCreateGuestSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn authentication_create_request_token(configuration: &configuration::Configuration, ) -> Result<models::AuthenticationCreateRequestToken200Response, Error<AuthenticationCreateRequestTokenError>> {

    let uri_str = format!("{}/3/authentication/token/new", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationCreateRequestToken200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationCreateRequestToken200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationCreateRequestTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn authentication_create_session(configuration: &configuration::Configuration, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::AuthenticationCreateSession200Response, Error<AuthenticationCreateSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/authentication/session/new", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationCreateSession200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationCreateSession200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationCreateSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This method allows an application to validate a request token by entering a username and password.
pub async fn authentication_create_session_from_login(configuration: &configuration::Configuration, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::AuthenticationCreateSessionFromLogin200Response, Error<AuthenticationCreateSessionFromLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/authentication/token/validate_with_login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationCreateSessionFromLogin200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationCreateSessionFromLogin200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationCreateSessionFromLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn authentication_create_session_from_v4_token(configuration: &configuration::Configuration, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::AuthenticationCreateSessionFromV4Token200Response, Error<AuthenticationCreateSessionFromV4TokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/authentication/session/convert/4", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationCreateSessionFromV4Token200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationCreateSessionFromV4Token200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationCreateSessionFromV4TokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn authentication_delete_session(configuration: &configuration::Configuration, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::AuthenticationDeleteSession200Response, Error<AuthenticationDeleteSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/authentication/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationDeleteSession200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationDeleteSession200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationDeleteSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test your API Key to see if it's valid.
pub async fn authentication_validate_key(configuration: &configuration::Configuration, ) -> Result<models::AuthenticationValidateKey200Response, Error<AuthenticationValidateKeyError>> {

    let uri_str = format!("{}/3/authentication", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticationValidateKey200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticationValidateKey200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationValidateKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an up to date list of the officially supported movie certifications on TMDB.
pub async fn certification_movie_list(configuration: &configuration::Configuration, ) -> Result<models::CertificationMovieList200Response, Error<CertificationMovieListError>> {

    let uri_str = format!("{}/3/certification/movie/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CertificationMovieList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CertificationMovieList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CertificationMovieListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn certifications_tv_list(configuration: &configuration::Configuration, ) -> Result<models::CertificationsTvList200Response, Error<CertificationsTvListError>> {

    let uri_str = format!("{}/3/certification/tv/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CertificationsTvList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CertificationsTvList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CertificationsTvListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all of the movie ids that have been changed in the past 24 hours.
pub async fn changes_movie_list(configuration: &configuration::Configuration, end_date: Option<String>, page: Option<i32>, start_date: Option<String>) -> Result<models::ChangesMovieList200Response, Error<ChangesMovieListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/movie/changes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangesMovieList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangesMovieList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangesMovieListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn changes_people_list(configuration: &configuration::Configuration, end_date: Option<String>, page: Option<i32>, start_date: Option<String>) -> Result<models::ChangesPeopleList200Response, Error<ChangesPeopleListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/person/changes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangesPeopleList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangesPeopleList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangesPeopleListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn changes_tv_list(configuration: &configuration::Configuration, end_date: Option<String>, page: Option<i32>, start_date: Option<String>) -> Result<models::ChangesTvList200Response, Error<ChangesTvListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/tv/changes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangesTvList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangesTvList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangesTvListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get collection details by ID.
pub async fn collection_details(configuration: &configuration::Configuration, collection_id: i32, language: Option<&str>) -> Result<models::CollectionDetails200Response, Error<CollectionDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_id = collection_id;
    let p_language = language;

    let uri_str = format!("{}/3/collection/{collection_id}", configuration.base_path, collection_id=p_collection_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CollectionDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CollectionDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CollectionDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the images that belong to a collection.
pub async fn collection_images(configuration: &configuration::Configuration, collection_id: i32, include_image_language: Option<&str>, language: Option<&str>) -> Result<models::CollectionImages200Response, Error<CollectionImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_id = collection_id;
    let p_include_image_language = include_image_language;
    let p_language = language;

    let uri_str = format!("{}/3/collection/{collection_id}/images", configuration.base_path, collection_id=p_collection_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_image_language {
        req_builder = req_builder.query(&[("include_image_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CollectionImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CollectionImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CollectionImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn collection_translations(configuration: &configuration::Configuration, collection_id: i32) -> Result<models::CollectionTranslations200Response, Error<CollectionTranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_id = collection_id;

    let uri_str = format!("{}/3/collection/{collection_id}/translations", configuration.base_path, collection_id=p_collection_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CollectionTranslations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CollectionTranslations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CollectionTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the company details by ID.
pub async fn company_alternative_names(configuration: &configuration::Configuration, company_id: i32) -> Result<models::CompanyAlternativeNames200Response, Error<CompanyAlternativeNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_company_id = company_id;

    let uri_str = format!("{}/3/company/{company_id}/alternative_names", configuration.base_path, company_id=p_company_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompanyAlternativeNames200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompanyAlternativeNames200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAlternativeNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the company details by ID.
pub async fn company_details(configuration: &configuration::Configuration, company_id: i32) -> Result<models::CompanyDetails200Response, Error<CompanyDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_company_id = company_id;

    let uri_str = format!("{}/3/company/{company_id}", configuration.base_path, company_id=p_company_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompanyDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompanyDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the company logos by id.
pub async fn company_images(configuration: &configuration::Configuration, company_id: i32) -> Result<models::CompanyImages200Response, Error<CompanyImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_company_id = company_id;

    let uri_str = format!("{}/3/company/{company_id}/images", configuration.base_path, company_id=p_company_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompanyImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompanyImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of countries (ISO 3166-1 tags) used throughout TMDB.
pub async fn configuration_countries(configuration: &configuration::Configuration, language: Option<&str>) -> Result<Vec<models::WatchProvidersAvailableRegions200ResponseResultsInner>, Error<ConfigurationCountriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;

    let uri_str = format!("{}/3/configuration/countries", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WatchProvidersAvailableRegions200ResponseResultsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WatchProvidersAvailableRegions200ResponseResultsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationCountriesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the API configuration details.
pub async fn configuration_details(configuration: &configuration::Configuration, ) -> Result<models::ConfigurationDetails200Response, Error<ConfigurationDetailsError>> {

    let uri_str = format!("{}/3/configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigurationDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigurationDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of the jobs and departments we use on TMDB.
pub async fn configuration_jobs(configuration: &configuration::Configuration, ) -> Result<Vec<models::ConfigurationJobs200ResponseInner>, Error<ConfigurationJobsError>> {

    let uri_str = format!("{}/3/configuration/jobs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ConfigurationJobs200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ConfigurationJobs200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationJobsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of languages (ISO 639-1 tags) used throughout TMDB.
pub async fn configuration_languages(configuration: &configuration::Configuration, ) -> Result<Vec<models::ConfigurationLanguages200ResponseInner>, Error<ConfigurationLanguagesError>> {

    let uri_str = format!("{}/3/configuration/languages", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ConfigurationLanguages200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ConfigurationLanguages200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationLanguagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of the officially supported translations on TMDB.
pub async fn configuration_primary_translations(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<ConfigurationPrimaryTranslationsError>> {

    let uri_str = format!("{}/3/configuration/primary_translations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationPrimaryTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of timezones used throughout TMDB.
pub async fn configuration_timezones(configuration: &configuration::Configuration, ) -> Result<Vec<models::ConfigurationTimezones200ResponseInner>, Error<ConfigurationTimezonesError>> {

    let uri_str = format!("{}/3/configuration/timezones", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ConfigurationTimezones200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ConfigurationTimezones200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationTimezonesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a movie or TV credit details by ID.
pub async fn credit_details(configuration: &configuration::Configuration, credit_id: &str) -> Result<models::CreditDetails200Response, Error<CreditDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_credit_id = credit_id;

    let uri_str = format!("{}/3/credit/{credit_id}", configuration.base_path, credit_id=crate::apis::urlencode(p_credit_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreditDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreditDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreditDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the alternative names of a network.
pub async fn details_copy(configuration: &configuration::Configuration, network_id: i32) -> Result<models::DetailsCopy200Response, Error<DetailsCopyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_network_id = network_id;

    let uri_str = format!("{}/3/network/{network_id}/alternative_names", configuration.base_path, network_id=p_network_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DetailsCopy200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DetailsCopy200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DetailsCopyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Find movies using over 30 filters and sort options.
pub async fn discover_movie(configuration: &configuration::Configuration, certification: Option<&str>, certification_period_gte: Option<&str>, certification_period_lte: Option<&str>, certification_country: Option<&str>, include_adult: Option<bool>, include_video: Option<bool>, language: Option<&str>, page: Option<i32>, primary_release_year: Option<i32>, primary_release_date_period_gte: Option<String>, primary_release_date_period_lte: Option<String>, region: Option<&str>, release_date_period_gte: Option<String>, release_date_period_lte: Option<String>, sort_by: Option<&str>, vote_average_period_gte: Option<f32>, vote_average_period_lte: Option<f32>, vote_count_period_gte: Option<f32>, vote_count_period_lte: Option<f32>, watch_region: Option<&str>, with_cast: Option<&str>, with_companies: Option<&str>, with_crew: Option<&str>, with_genres: Option<&str>, with_keywords: Option<&str>, with_origin_country: Option<&str>, with_original_language: Option<&str>, with_people: Option<&str>, with_release_type: Option<i32>, with_runtime_period_gte: Option<i32>, with_runtime_period_lte: Option<i32>, with_watch_monetization_types: Option<&str>, with_watch_providers: Option<&str>, without_companies: Option<&str>, without_genres: Option<&str>, without_keywords: Option<&str>, without_watch_providers: Option<&str>, year: Option<i32>) -> Result<models::DiscoverMovie200Response, Error<DiscoverMovieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_certification = certification;
    let p_certification_period_gte = certification_period_gte;
    let p_certification_period_lte = certification_period_lte;
    let p_certification_country = certification_country;
    let p_include_adult = include_adult;
    let p_include_video = include_video;
    let p_language = language;
    let p_page = page;
    let p_primary_release_year = primary_release_year;
    let p_primary_release_date_period_gte = primary_release_date_period_gte;
    let p_primary_release_date_period_lte = primary_release_date_period_lte;
    let p_region = region;
    let p_release_date_period_gte = release_date_period_gte;
    let p_release_date_period_lte = release_date_period_lte;
    let p_sort_by = sort_by;
    let p_vote_average_period_gte = vote_average_period_gte;
    let p_vote_average_period_lte = vote_average_period_lte;
    let p_vote_count_period_gte = vote_count_period_gte;
    let p_vote_count_period_lte = vote_count_period_lte;
    let p_watch_region = watch_region;
    let p_with_cast = with_cast;
    let p_with_companies = with_companies;
    let p_with_crew = with_crew;
    let p_with_genres = with_genres;
    let p_with_keywords = with_keywords;
    let p_with_origin_country = with_origin_country;
    let p_with_original_language = with_original_language;
    let p_with_people = with_people;
    let p_with_release_type = with_release_type;
    let p_with_runtime_period_gte = with_runtime_period_gte;
    let p_with_runtime_period_lte = with_runtime_period_lte;
    let p_with_watch_monetization_types = with_watch_monetization_types;
    let p_with_watch_providers = with_watch_providers;
    let p_without_companies = without_companies;
    let p_without_genres = without_genres;
    let p_without_keywords = without_keywords;
    let p_without_watch_providers = without_watch_providers;
    let p_year = year;

    let uri_str = format!("{}/3/discover/movie", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_certification {
        req_builder = req_builder.query(&[("certification", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_certification_period_gte {
        req_builder = req_builder.query(&[("certification.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_certification_period_lte {
        req_builder = req_builder.query(&[("certification.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_certification_country {
        req_builder = req_builder.query(&[("certification_country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_video {
        req_builder = req_builder.query(&[("include_video", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_primary_release_year {
        req_builder = req_builder.query(&[("primary_release_year", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_primary_release_date_period_gte {
        req_builder = req_builder.query(&[("primary_release_date.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_primary_release_date_period_lte {
        req_builder = req_builder.query(&[("primary_release_date.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_release_date_period_gte {
        req_builder = req_builder.query(&[("release_date.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_release_date_period_lte {
        req_builder = req_builder.query(&[("release_date.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_average_period_gte {
        req_builder = req_builder.query(&[("vote_average.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_average_period_lte {
        req_builder = req_builder.query(&[("vote_average.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_count_period_gte {
        req_builder = req_builder.query(&[("vote_count.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_count_period_lte {
        req_builder = req_builder.query(&[("vote_count.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_watch_region {
        req_builder = req_builder.query(&[("watch_region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_cast {
        req_builder = req_builder.query(&[("with_cast", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_companies {
        req_builder = req_builder.query(&[("with_companies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_crew {
        req_builder = req_builder.query(&[("with_crew", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_genres {
        req_builder = req_builder.query(&[("with_genres", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_keywords {
        req_builder = req_builder.query(&[("with_keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_origin_country {
        req_builder = req_builder.query(&[("with_origin_country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_original_language {
        req_builder = req_builder.query(&[("with_original_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_people {
        req_builder = req_builder.query(&[("with_people", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_release_type {
        req_builder = req_builder.query(&[("with_release_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_runtime_period_gte {
        req_builder = req_builder.query(&[("with_runtime.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_runtime_period_lte {
        req_builder = req_builder.query(&[("with_runtime.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_watch_monetization_types {
        req_builder = req_builder.query(&[("with_watch_monetization_types", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_watch_providers {
        req_builder = req_builder.query(&[("with_watch_providers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_companies {
        req_builder = req_builder.query(&[("without_companies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_genres {
        req_builder = req_builder.query(&[("without_genres", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_keywords {
        req_builder = req_builder.query(&[("without_keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_watch_providers {
        req_builder = req_builder.query(&[("without_watch_providers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_year {
        req_builder = req_builder.query(&[("year", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverMovie200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverMovie200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoverMovieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Find TV shows using over 30 filters and sort options.
pub async fn discover_tv(configuration: &configuration::Configuration, air_date_period_gte: Option<String>, air_date_period_lte: Option<String>, first_air_date_year: Option<i32>, first_air_date_period_gte: Option<String>, first_air_date_period_lte: Option<String>, include_adult: Option<bool>, include_null_first_air_dates: Option<bool>, language: Option<&str>, page: Option<i32>, screened_theatrically: Option<bool>, sort_by: Option<&str>, timezone: Option<&str>, vote_average_period_gte: Option<f32>, vote_average_period_lte: Option<f32>, vote_count_period_gte: Option<f32>, vote_count_period_lte: Option<f32>, watch_region: Option<&str>, with_companies: Option<&str>, with_genres: Option<&str>, with_keywords: Option<&str>, with_networks: Option<i32>, with_origin_country: Option<&str>, with_original_language: Option<&str>, with_runtime_period_gte: Option<i32>, with_runtime_period_lte: Option<i32>, with_status: Option<&str>, with_watch_monetization_types: Option<&str>, with_watch_providers: Option<&str>, without_companies: Option<&str>, without_genres: Option<&str>, without_keywords: Option<&str>, without_watch_providers: Option<&str>, with_type: Option<&str>) -> Result<models::DiscoverTv200Response, Error<DiscoverTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_air_date_period_gte = air_date_period_gte;
    let p_air_date_period_lte = air_date_period_lte;
    let p_first_air_date_year = first_air_date_year;
    let p_first_air_date_period_gte = first_air_date_period_gte;
    let p_first_air_date_period_lte = first_air_date_period_lte;
    let p_include_adult = include_adult;
    let p_include_null_first_air_dates = include_null_first_air_dates;
    let p_language = language;
    let p_page = page;
    let p_screened_theatrically = screened_theatrically;
    let p_sort_by = sort_by;
    let p_timezone = timezone;
    let p_vote_average_period_gte = vote_average_period_gte;
    let p_vote_average_period_lte = vote_average_period_lte;
    let p_vote_count_period_gte = vote_count_period_gte;
    let p_vote_count_period_lte = vote_count_period_lte;
    let p_watch_region = watch_region;
    let p_with_companies = with_companies;
    let p_with_genres = with_genres;
    let p_with_keywords = with_keywords;
    let p_with_networks = with_networks;
    let p_with_origin_country = with_origin_country;
    let p_with_original_language = with_original_language;
    let p_with_runtime_period_gte = with_runtime_period_gte;
    let p_with_runtime_period_lte = with_runtime_period_lte;
    let p_with_status = with_status;
    let p_with_watch_monetization_types = with_watch_monetization_types;
    let p_with_watch_providers = with_watch_providers;
    let p_without_companies = without_companies;
    let p_without_genres = without_genres;
    let p_without_keywords = without_keywords;
    let p_without_watch_providers = without_watch_providers;
    let p_with_type = with_type;

    let uri_str = format!("{}/3/discover/tv", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_air_date_period_gte {
        req_builder = req_builder.query(&[("air_date.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_air_date_period_lte {
        req_builder = req_builder.query(&[("air_date.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_first_air_date_year {
        req_builder = req_builder.query(&[("first_air_date_year", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_first_air_date_period_gte {
        req_builder = req_builder.query(&[("first_air_date.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_first_air_date_period_lte {
        req_builder = req_builder.query(&[("first_air_date.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_null_first_air_dates {
        req_builder = req_builder.query(&[("include_null_first_air_dates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_screened_theatrically {
        req_builder = req_builder.query(&[("screened_theatrically", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_average_period_gte {
        req_builder = req_builder.query(&[("vote_average.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_average_period_lte {
        req_builder = req_builder.query(&[("vote_average.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_count_period_gte {
        req_builder = req_builder.query(&[("vote_count.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vote_count_period_lte {
        req_builder = req_builder.query(&[("vote_count.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_watch_region {
        req_builder = req_builder.query(&[("watch_region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_companies {
        req_builder = req_builder.query(&[("with_companies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_genres {
        req_builder = req_builder.query(&[("with_genres", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_keywords {
        req_builder = req_builder.query(&[("with_keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_networks {
        req_builder = req_builder.query(&[("with_networks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_origin_country {
        req_builder = req_builder.query(&[("with_origin_country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_original_language {
        req_builder = req_builder.query(&[("with_original_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_runtime_period_gte {
        req_builder = req_builder.query(&[("with_runtime.gte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_runtime_period_lte {
        req_builder = req_builder.query(&[("with_runtime.lte", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_status {
        req_builder = req_builder.query(&[("with_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_watch_monetization_types {
        req_builder = req_builder.query(&[("with_watch_monetization_types", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_watch_providers {
        req_builder = req_builder.query(&[("with_watch_providers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_companies {
        req_builder = req_builder.query(&[("without_companies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_genres {
        req_builder = req_builder.query(&[("without_genres", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_keywords {
        req_builder = req_builder.query(&[("without_keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_without_watch_providers {
        req_builder = req_builder.query(&[("without_watch_providers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_type {
        req_builder = req_builder.query(&[("with_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoverTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Find data by external ID's.
pub async fn find_by_id(configuration: &configuration::Configuration, external_id: &str, external_source: &str, language: Option<&str>) -> Result<models::FindById200Response, Error<FindByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_external_id = external_id;
    let p_external_source = external_source;
    let p_language = language;

    let uri_str = format!("{}/3/find/{external_id}", configuration.base_path, external_id=crate::apis::urlencode(p_external_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("external_source", &p_external_source.to_string())]);
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FindById200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FindById200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of official genres for movies.
pub async fn genre_movie_list(configuration: &configuration::Configuration, language: Option<&str>) -> Result<models::GenreMovieList200Response, Error<GenreMovieListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;

    let uri_str = format!("{}/3/genre/movie/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GenreMovieList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GenreMovieList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenreMovieListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of official genres for TV shows.
pub async fn genre_tv_list(configuration: &configuration::Configuration, language: Option<&str>) -> Result<models::GenreTvList200Response, Error<GenreTvListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;

    let uri_str = format!("{}/3/genre/tv/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GenreTvList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GenreTvList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenreTvListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rated movies for a guest session.
pub async fn guest_session_rated_movies(configuration: &configuration::Configuration, guest_session_id: &str, language: Option<&str>, page: Option<i32>, sort_by: Option<&str>) -> Result<models::GuestSessionRatedMovies200Response, Error<GuestSessionRatedMoviesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_guest_session_id = guest_session_id;
    let p_language = language;
    let p_page = page;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/guest_session/{guest_session_id}/rated/movies", configuration.base_path, guest_session_id=crate::apis::urlencode(p_guest_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GuestSessionRatedMovies200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GuestSessionRatedMovies200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GuestSessionRatedMoviesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rated TV shows for a guest session.
pub async fn guest_session_rated_tv(configuration: &configuration::Configuration, guest_session_id: &str, language: Option<&str>, page: Option<i32>, sort_by: Option<&str>) -> Result<models::GuestSessionRatedTv200Response, Error<GuestSessionRatedTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_guest_session_id = guest_session_id;
    let p_language = language;
    let p_page = page;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/guest_session/{guest_session_id}/rated/tv", configuration.base_path, guest_session_id=crate::apis::urlencode(p_guest_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GuestSessionRatedTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GuestSessionRatedTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GuestSessionRatedTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rated TV episodes for a guest session.
pub async fn guest_session_rated_tv_episodes(configuration: &configuration::Configuration, guest_session_id: &str, language: Option<&str>, page: Option<i32>, sort_by: Option<&str>) -> Result<models::GuestSessionRatedTvEpisodes200Response, Error<GuestSessionRatedTvEpisodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_guest_session_id = guest_session_id;
    let p_language = language;
    let p_page = page;
    let p_sort_by = sort_by;

    let uri_str = format!("{}/3/guest_session/{guest_session_id}/rated/tv/episodes", configuration.base_path, guest_session_id=crate::apis::urlencode(p_guest_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GuestSessionRatedTvEpisodes200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GuestSessionRatedTvEpisodes200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GuestSessionRatedTvEpisodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn keyword_details(configuration: &configuration::Configuration, keyword_id: i32) -> Result<models::KeywordDetails200Response, Error<KeywordDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_keyword_id = keyword_id;

    let uri_str = format!("{}/3/keyword/{keyword_id}", configuration.base_path, keyword_id=p_keyword_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeywordDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeywordDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<KeywordDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn keyword_movies(configuration: &configuration::Configuration, keyword_id: &str, include_adult: Option<bool>, language: Option<&str>, page: Option<i32>) -> Result<models::KeywordMovies200Response, Error<KeywordMoviesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_keyword_id = keyword_id;
    let p_include_adult = include_adult;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/keyword/{keyword_id}/movies", configuration.base_path, keyword_id=crate::apis::urlencode(p_keyword_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeywordMovies200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeywordMovies200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<KeywordMoviesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a movie to a list.
pub async fn list_add_movie(configuration: &configuration::Configuration, list_id: i32, session_id: &str, list_add_movie_request: Option<models::ListAddMovieRequest>) -> Result<models::ListDelete200Response, Error<ListAddMovieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_id = list_id;
    let p_session_id = session_id;
    let p_list_add_movie_request = list_add_movie_request;

    let uri_str = format!("{}/3/list/{list_id}/add_item", configuration.base_path, list_id=p_list_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("session_id", &p_session_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_list_add_movie_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAddMovieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use this method to check if an item has already been added to the list.
pub async fn list_check_item_status(configuration: &configuration::Configuration, list_id: i32, language: Option<&str>, movie_id: Option<i32>) -> Result<models::ListCheckItemStatus200Response, Error<ListCheckItemStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_id = list_id;
    let p_language = language;
    let p_movie_id = movie_id;

    let uri_str = format!("{}/3/list/{list_id}/item_status", configuration.base_path, list_id=p_list_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_movie_id {
        req_builder = req_builder.query(&[("movie_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListCheckItemStatus200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListCheckItemStatus200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListCheckItemStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clear all items from a list.
pub async fn list_clear(configuration: &configuration::Configuration, list_id: i32, session_id: &str, confirm: bool) -> Result<models::ListDelete200Response, Error<ListClearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_id = list_id;
    let p_session_id = session_id;
    let p_confirm = confirm;

    let uri_str = format!("{}/3/list/{list_id}/clear", configuration.base_path, list_id=p_list_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("session_id", &p_session_id.to_string())]);
    req_builder = req_builder.query(&[("confirm", &p_confirm.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListClearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn list_create(configuration: &configuration::Configuration, session_id: &str, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::ListCreate200Response, Error<ListCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("session_id", &p_session_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a list.
pub async fn list_delete(configuration: &configuration::Configuration, list_id: i32, session_id: &str) -> Result<models::ListDelete200Response, Error<ListDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_id = list_id;
    let p_session_id = session_id;

    let uri_str = format!("{}/3/list/{list_id}", configuration.base_path, list_id=p_list_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("session_id", &p_session_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn list_details(configuration: &configuration::Configuration, list_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::ListDetails200Response, Error<ListDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_id = list_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/list/{list_id}", configuration.base_path, list_id=p_list_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a movie from a list.
pub async fn list_remove_movie(configuration: &configuration::Configuration, list_id: i32, session_id: &str, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::MovieDeleteRating200Response, Error<ListRemoveMovieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_list_id = list_id;
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/list/{list_id}/remove_item", configuration.base_path, list_id=p_list_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("session_id", &p_session_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieDeleteRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieDeleteRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListRemoveMovieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the lists that a TV series has been added to.
pub async fn lists_copy(configuration: &configuration::Configuration, series_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::ListsCopy200Response, Error<ListsCopyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/tv/{series_id}/lists", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListsCopy200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListsCopy200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListsCopyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rating, watchlist and favourite status of an account.
pub async fn movie_account_states(configuration: &configuration::Configuration, movie_id: i32, session_id: Option<&str>, guest_session_id: Option<&str>) -> Result<models::MovieAccountStates200Response, Error<MovieAccountStatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_session_id = session_id;
    let p_guest_session_id = guest_session_id;

    let uri_str = format!("{}/3/movie/{movie_id}/account_states", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAccountStates200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAccountStates200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieAccountStatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate a movie and save it to your rated list.
pub async fn movie_add_rating(configuration: &configuration::Configuration, movie_id: i32, content_type: &str, guest_session_id: Option<&str>, session_id: Option<&str>, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::MovieAddRating200Response, Error<MovieAddRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_content_type = content_type;
    let p_guest_session_id = guest_session_id;
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/movie/{movie_id}/rating", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Content-Type", p_content_type.to_string());
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAddRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAddRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieAddRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the alternative titles for a movie.
pub async fn movie_alternative_titles(configuration: &configuration::Configuration, movie_id: i32, country: Option<&str>) -> Result<models::MovieAlternativeTitles200Response, Error<MovieAlternativeTitlesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_country = country;

    let uri_str = format!("{}/3/movie/{movie_id}/alternative_titles", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAlternativeTitles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAlternativeTitles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieAlternativeTitlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the recent changes for a movie.
pub async fn movie_changes(configuration: &configuration::Configuration, movie_id: i32, end_date: Option<String>, page: Option<i32>, start_date: Option<String>) -> Result<models::MovieChanges200Response, Error<MovieChangesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/movie/{movie_id}/changes", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieChanges200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieChanges200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieChangesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn movie_credits(configuration: &configuration::Configuration, movie_id: i32, language: Option<&str>) -> Result<models::MovieCredits200Response, Error<MovieCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_language = language;

    let uri_str = format!("{}/3/movie/{movie_id}/credits", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a user rating.
pub async fn movie_delete_rating(configuration: &configuration::Configuration, movie_id: i32, content_type: Option<&str>, guest_session_id: Option<&str>, session_id: Option<&str>) -> Result<models::MovieDeleteRating200Response, Error<MovieDeleteRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_content_type = content_type;
    let p_guest_session_id = guest_session_id;
    let p_session_id = session_id;

    let uri_str = format!("{}/3/movie/{movie_id}/rating", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieDeleteRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieDeleteRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieDeleteRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the top level details of a movie by ID.
pub async fn movie_details(configuration: &configuration::Configuration, movie_id: i32, append_to_response: Option<&str>, language: Option<&str>) -> Result<models::MovieDetails200Response, Error<MovieDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_append_to_response = append_to_response;
    let p_language = language;

    let uri_str = format!("{}/3/movie/{movie_id}", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_append_to_response {
        req_builder = req_builder.query(&[("append_to_response", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn movie_external_ids(configuration: &configuration::Configuration, movie_id: i32) -> Result<models::MovieExternalIds200Response, Error<MovieExternalIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;

    let uri_str = format!("{}/3/movie/{movie_id}/external_ids", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieExternalIds200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieExternalIds200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieExternalIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the images that belong to a movie.
pub async fn movie_images(configuration: &configuration::Configuration, movie_id: i32, include_image_language: Option<&str>, language: Option<&str>) -> Result<models::MovieImages200Response, Error<MovieImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_include_image_language = include_image_language;
    let p_language = language;

    let uri_str = format!("{}/3/movie/{movie_id}/images", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_image_language {
        req_builder = req_builder.query(&[("include_image_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn movie_keywords(configuration: &configuration::Configuration, movie_id: &str) -> Result<models::MovieKeywords200Response, Error<MovieKeywordsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;

    let uri_str = format!("{}/3/movie/{movie_id}/keywords", configuration.base_path, movie_id=crate::apis::urlencode(p_movie_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieKeywords200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieKeywords200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieKeywordsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the newest movie ID.
pub async fn movie_latest_id(configuration: &configuration::Configuration, ) -> Result<models::MovieLatestId200Response, Error<MovieLatestIdError>> {

    let uri_str = format!("{}/3/movie/latest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieLatestId200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieLatestId200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieLatestIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the lists that a movie has been added to.
pub async fn movie_lists(configuration: &configuration::Configuration, movie_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::MovieLists200Response, Error<MovieListsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/movie/{movie_id}/lists", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieLists200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieLists200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieListsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of movies that are currently in theatres.
pub async fn movie_now_playing_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>, region: Option<&str>) -> Result<models::MovieNowPlayingList200Response, Error<MovieNowPlayingListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;
    let p_region = region;

    let uri_str = format!("{}/3/movie/now_playing", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieNowPlayingList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieNowPlayingList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieNowPlayingListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of movies ordered by popularity.
pub async fn movie_popular_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>, region: Option<&str>) -> Result<models::MoviePopularList200Response, Error<MoviePopularListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;
    let p_region = region;

    let uri_str = format!("{}/3/movie/popular", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MoviePopularList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MoviePopularList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoviePopularListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn movie_recommendations(configuration: &configuration::Configuration, movie_id: i32, language: Option<&str>, page: Option<i32>) -> Result<serde_json::Value, Error<MovieRecommendationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/movie/{movie_id}/recommendations", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieRecommendationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the release dates and certifications for a movie.
pub async fn movie_release_dates(configuration: &configuration::Configuration, movie_id: i32) -> Result<models::MovieReleaseDates200Response, Error<MovieReleaseDatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;

    let uri_str = format!("{}/3/movie/{movie_id}/release_dates", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieReleaseDates200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieReleaseDates200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieReleaseDatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the user reviews for a movie.
pub async fn movie_reviews(configuration: &configuration::Configuration, movie_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::MovieReviews200Response, Error<MovieReviewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/movie/{movie_id}/reviews", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieReviews200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieReviews200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieReviewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the similar movies based on genres and keywords.
pub async fn movie_similar(configuration: &configuration::Configuration, movie_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::MovieSimilar200Response, Error<MovieSimilarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/movie/{movie_id}/similar", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieSimilar200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieSimilar200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieSimilarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of movies ordered by rating.
pub async fn movie_top_rated_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>, region: Option<&str>) -> Result<models::MovieTopRatedList200Response, Error<MovieTopRatedListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;
    let p_region = region;

    let uri_str = format!("{}/3/movie/top_rated", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieTopRatedList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieTopRatedList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieTopRatedListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the translations for a movie.
pub async fn movie_translations(configuration: &configuration::Configuration, movie_id: i32) -> Result<models::MovieTranslations200Response, Error<MovieTranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;

    let uri_str = format!("{}/3/movie/{movie_id}/translations", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieTranslations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieTranslations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of movies that are being released soon.
pub async fn movie_upcoming_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>, region: Option<&str>) -> Result<models::MovieUpcomingList200Response, Error<MovieUpcomingListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;
    let p_region = region;

    let uri_str = format!("{}/3/movie/upcoming", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieUpcomingList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieUpcomingList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieUpcomingListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn movie_videos(configuration: &configuration::Configuration, movie_id: i32, language: Option<&str>) -> Result<models::MovieVideos200Response, Error<MovieVideosError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;
    let p_language = language;

    let uri_str = format!("{}/3/movie/{movie_id}/videos", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieVideos200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieVideos200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieVideosError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of streaming providers we have for a movie.
pub async fn movie_watch_providers(configuration: &configuration::Configuration, movie_id: i32) -> Result<models::MovieWatchProviders200Response, Error<MovieWatchProvidersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_movie_id = movie_id;

    let uri_str = format!("{}/3/movie/{movie_id}/watch/providers", configuration.base_path, movie_id=p_movie_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieWatchProviders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieWatchProviders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MovieWatchProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn network_details(configuration: &configuration::Configuration, network_id: i32) -> Result<models::NetworkDetails200Response, Error<NetworkDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_network_id = network_id;

    let uri_str = format!("{}/3/network/{network_id}", configuration.base_path, network_id=p_network_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NetworkDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NetworkDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<NetworkDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the recent changes for a person.
pub async fn person_changes(configuration: &configuration::Configuration, person_id: i32, end_date: Option<String>, page: Option<i32>, start_date: Option<String>) -> Result<models::PersonChanges200Response, Error<PersonChangesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/person/{person_id}/changes", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonChanges200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonChanges200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonChangesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the combined movie and TV credits that belong to a person.
pub async fn person_combined_credits(configuration: &configuration::Configuration, person_id: &str, language: Option<&str>) -> Result<models::PersonCombinedCredits200Response, Error<PersonCombinedCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_language = language;

    let uri_str = format!("{}/3/person/{person_id}/combined_credits", configuration.base_path, person_id=crate::apis::urlencode(p_person_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonCombinedCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonCombinedCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonCombinedCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the top level details of a person.
pub async fn person_details(configuration: &configuration::Configuration, person_id: i32, append_to_response: Option<&str>, language: Option<&str>) -> Result<models::PersonDetails200Response, Error<PersonDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_append_to_response = append_to_response;
    let p_language = language;

    let uri_str = format!("{}/3/person/{person_id}", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_append_to_response {
        req_builder = req_builder.query(&[("append_to_response", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the external ID's that belong to a person.
pub async fn person_external_ids(configuration: &configuration::Configuration, person_id: i32) -> Result<models::PersonExternalIds200Response, Error<PersonExternalIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!("{}/3/person/{person_id}/external_ids", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonExternalIds200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonExternalIds200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonExternalIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the profile images that belong to a person.
pub async fn person_images(configuration: &configuration::Configuration, person_id: i32) -> Result<models::PersonImages200Response, Error<PersonImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!("{}/3/person/{person_id}/images", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the newest created person. This is a live response and will continuously change.
pub async fn person_latest_id(configuration: &configuration::Configuration, ) -> Result<models::PersonLatestId200Response, Error<PersonLatestIdError>> {

    let uri_str = format!("{}/3/person/latest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonLatestId200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonLatestId200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonLatestIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the movie credits for a person.
pub async fn person_movie_credits(configuration: &configuration::Configuration, person_id: i32, language: Option<&str>) -> Result<models::PersonMovieCredits200Response, Error<PersonMovieCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_language = language;

    let uri_str = format!("{}/3/person/{person_id}/movie_credits", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonMovieCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonMovieCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonMovieCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of people ordered by popularity.
pub async fn person_popular_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>) -> Result<models::PersonPopularList200Response, Error<PersonPopularListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/person/popular", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonPopularList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonPopularList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonPopularListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the tagged images for a person.
pub async fn person_tagged_images(configuration: &configuration::Configuration, person_id: i32, page: Option<i32>) -> Result<models::PersonTaggedImages200Response, Error<PersonTaggedImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_page = page;

    let uri_str = format!("{}/3/person/{person_id}/tagged_images", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonTaggedImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonTaggedImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonTaggedImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the TV credits that belong to a person.
pub async fn person_tv_credits(configuration: &configuration::Configuration, person_id: i32, language: Option<&str>) -> Result<models::PersonTvCredits200Response, Error<PersonTvCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;
    let p_language = language;

    let uri_str = format!("{}/3/person/{person_id}/tv_credits", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonTvCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonTvCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PersonTvCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the details of a movie or TV show review.
pub async fn review_details(configuration: &configuration::Configuration, review_id: &str) -> Result<models::ReviewDetails200Response, Error<ReviewDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_review_id = review_id;

    let uri_str = format!("{}/3/review/{review_id}", configuration.base_path, review_id=crate::apis::urlencode(p_review_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReviewDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReviewDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReviewDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for collections by their original, translated and alternative names.
pub async fn search_collection(configuration: &configuration::Configuration, query: &str, include_adult: Option<bool>, language: Option<&str>, page: Option<i32>, region: Option<&str>) -> Result<models::SearchCollection200Response, Error<SearchCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_include_adult = include_adult;
    let p_language = language;
    let p_page = page;
    let p_region = region;

    let uri_str = format!("{}/3/search/collection", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchCollection200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchCollection200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for companies by their original and alternative names.
pub async fn search_company(configuration: &configuration::Configuration, query: &str, page: Option<i32>) -> Result<models::SearchCompany200Response, Error<SearchCompanyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_page = page;

    let uri_str = format!("{}/3/search/company", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchCompany200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchCompany200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCompanyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for keywords by their name.
pub async fn search_keyword(configuration: &configuration::Configuration, query: &str, page: Option<i32>) -> Result<models::SearchKeyword200Response, Error<SearchKeywordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_page = page;

    let uri_str = format!("{}/3/search/keyword", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchKeyword200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchKeyword200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchKeywordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for movies by their original, translated and alternative titles.
pub async fn search_movie(configuration: &configuration::Configuration, query: &str, include_adult: Option<bool>, language: Option<&str>, primary_release_year: Option<&str>, page: Option<i32>, region: Option<&str>, year: Option<&str>) -> Result<models::SearchMovie200Response, Error<SearchMovieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_include_adult = include_adult;
    let p_language = language;
    let p_primary_release_year = primary_release_year;
    let p_page = page;
    let p_region = region;
    let p_year = year;

    let uri_str = format!("{}/3/search/movie", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_primary_release_year {
        req_builder = req_builder.query(&[("primary_release_year", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_year {
        req_builder = req_builder.query(&[("year", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchMovie200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchMovie200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchMovieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use multi search when you want to search for movies, TV shows and people in a single request.
pub async fn search_multi(configuration: &configuration::Configuration, query: &str, include_adult: Option<bool>, language: Option<&str>, page: Option<i32>) -> Result<models::SearchMulti200Response, Error<SearchMultiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_include_adult = include_adult;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/search/multi", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchMulti200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchMulti200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchMultiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for people by their name and also known as names.
pub async fn search_person(configuration: &configuration::Configuration, query: &str, include_adult: Option<bool>, language: Option<&str>, page: Option<i32>) -> Result<models::SearchPerson200Response, Error<SearchPersonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_include_adult = include_adult;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/search/person", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchPerson200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchPerson200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchPersonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for TV shows by their original, translated and also known as names.
pub async fn search_tv(configuration: &configuration::Configuration, query: &str, first_air_date_year: Option<i32>, include_adult: Option<bool>, language: Option<&str>, page: Option<i32>, year: Option<i32>) -> Result<models::SearchTv200Response, Error<SearchTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query = query;
    let p_first_air_date_year = first_air_date_year;
    let p_include_adult = include_adult;
    let p_language = language;
    let p_page = page;
    let p_year = year;

    let uri_str = format!("{}/3/search/tv", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_first_air_date_year {
        req_builder = req_builder.query(&[("first_air_date_year", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_adult {
        req_builder = req_builder.query(&[("include_adult", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_year {
        req_builder = req_builder.query(&[("year", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the translations that belong to a person.
pub async fn translations(configuration: &configuration::Configuration, person_id: i32) -> Result<models::Translations200Response, Error<TranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_person_id = person_id;

    let uri_str = format!("{}/3/person/{person_id}/translations", configuration.base_path, person_id=p_person_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Translations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Translations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the trending movies, TV shows and people.
pub async fn trending_all(configuration: &configuration::Configuration, time_window: &str, language: Option<&str>) -> Result<models::TrendingAll200Response, Error<TrendingAllError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_time_window = time_window;
    let p_language = language;

    let uri_str = format!("{}/3/trending/all/{time_window}", configuration.base_path, time_window=crate::apis::urlencode(p_time_window));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrendingAll200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrendingAll200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrendingAllError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the trending movies on TMDB.
pub async fn trending_movies(configuration: &configuration::Configuration, time_window: &str, language: Option<&str>) -> Result<models::TrendingAll200Response, Error<TrendingMoviesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_time_window = time_window;
    let p_language = language;

    let uri_str = format!("{}/3/trending/movie/{time_window}", configuration.base_path, time_window=crate::apis::urlencode(p_time_window));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrendingAll200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrendingAll200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrendingMoviesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the trending people on TMDB.
pub async fn trending_people(configuration: &configuration::Configuration, time_window: &str, language: Option<&str>) -> Result<models::TrendingPeople200Response, Error<TrendingPeopleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_time_window = time_window;
    let p_language = language;

    let uri_str = format!("{}/3/trending/person/{time_window}", configuration.base_path, time_window=crate::apis::urlencode(p_time_window));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrendingPeople200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrendingPeople200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrendingPeopleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the trending TV shows on TMDB.
pub async fn trending_tv(configuration: &configuration::Configuration, time_window: &str, language: Option<&str>) -> Result<models::TrendingTv200Response, Error<TrendingTvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_time_window = time_window;
    let p_language = language;

    let uri_str = format!("{}/3/trending/tv/{time_window}", configuration.base_path, time_window=crate::apis::urlencode(p_time_window));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrendingTv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrendingTv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrendingTvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rating, watchlist and favourite status.
pub async fn tv_episode_account_states(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32, session_id: Option<&str>, guest_session_id: Option<&str>) -> Result<models::MovieAccountStates200Response, Error<TvEpisodeAccountStatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_session_id = session_id;
    let p_guest_session_id = guest_session_id;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/account_states", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAccountStates200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAccountStates200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeAccountStatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate a TV episode and save it to your rated list.
pub async fn tv_episode_add_rating(configuration: &configuration::Configuration, series_id: i32, content_type: &str, season_number: i32, episode_number: i32, guest_session_id: Option<&str>, session_id: Option<&str>, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::MovieAddRating200Response, Error<TvEpisodeAddRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_content_type = content_type;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_guest_session_id = guest_session_id;
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Content-Type", p_content_type.to_string());
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAddRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAddRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeAddRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the recent changes for a TV episode.
pub async fn tv_episode_changes_by_id(configuration: &configuration::Configuration, episode_id: i32) -> Result<models::TvEpisodeChangesById200Response, Error<TvEpisodeChangesByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_episode_id = episode_id;

    let uri_str = format!("{}/3/tv/episode/{episode_id}/changes", configuration.base_path, episode_id=p_episode_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeChangesById200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeChangesById200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeChangesByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn tv_episode_credits(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32, language: Option<&str>) -> Result<models::TvEpisodeCredits200Response, Error<TvEpisodeCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/credits", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete your rating on a TV episode.
pub async fn tv_episode_delete_rating(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32, content_type: Option<&str>, guest_session_id: Option<&str>, session_id: Option<&str>) -> Result<models::MovieDeleteRating200Response, Error<TvEpisodeDeleteRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_content_type = content_type;
    let p_guest_session_id = guest_session_id;
    let p_session_id = session_id;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieDeleteRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieDeleteRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeDeleteRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the details of a TV episode.
pub async fn tv_episode_details(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32, append_to_response: Option<&str>, language: Option<&str>) -> Result<models::TvEpisodeDetails200Response, Error<TvEpisodeDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_append_to_response = append_to_response;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_append_to_response {
        req_builder = req_builder.query(&[("append_to_response", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of external IDs that have been added to a TV episode.
pub async fn tv_episode_external_ids(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: &str) -> Result<models::TvEpisodeExternalIds200Response, Error<TvEpisodeExternalIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/external_ids", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=crate::apis::urlencode(p_episode_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeExternalIds200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeExternalIds200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeExternalIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a TV episode group.
pub async fn tv_episode_group_details(configuration: &configuration::Configuration, tv_episode_group_id: &str) -> Result<models::TvEpisodeGroupDetails200Response, Error<TvEpisodeGroupDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tv_episode_group_id = tv_episode_group_id;

    let uri_str = format!("{}/3/tv/episode_group/{tv_episode_group_id}", configuration.base_path, tv_episode_group_id=crate::apis::urlencode(p_tv_episode_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeGroupDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeGroupDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeGroupDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the images that belong to a TV episode.
pub async fn tv_episode_images(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32, include_image_language: Option<&str>, language: Option<&str>) -> Result<models::TvEpisodeImages200Response, Error<TvEpisodeImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_include_image_language = include_image_language;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/images", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_image_language {
        req_builder = req_builder.query(&[("include_image_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the translations that have been added to a TV episode.
pub async fn tv_episode_translations(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32) -> Result<models::TvEpisodeTranslations200Response, Error<TvEpisodeTranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/translations", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvEpisodeTranslations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvEpisodeTranslations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the videos that belong to a TV episode.
pub async fn tv_episode_videos(configuration: &configuration::Configuration, series_id: i32, season_number: i32, episode_number: i32, include_video_language: Option<&str>, language: Option<&str>) -> Result<models::TvSeasonVideos200Response, Error<TvEpisodeVideosError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_episode_number = episode_number;
    let p_include_video_language = include_video_language;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/videos", configuration.base_path, series_id=p_series_id, season_number=p_season_number, episode_number=p_episode_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_video_language {
        req_builder = req_builder.query(&[("include_video_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonVideos200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonVideos200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvEpisodeVideosError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rating, watchlist and favourite status.
pub async fn tv_season_account_states(configuration: &configuration::Configuration, series_id: i32, season_number: i32, session_id: Option<&str>, guest_session_id: Option<&str>) -> Result<models::TvSeasonAccountStates200Response, Error<TvSeasonAccountStatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_session_id = session_id;
    let p_guest_session_id = guest_session_id;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/account_states", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonAccountStates200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonAccountStates200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonAccountStatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the aggregate credits (cast and crew) that have been added to a TV season.
pub async fn tv_season_aggregate_credits(configuration: &configuration::Configuration, series_id: i32, season_number: i32, language: Option<&str>) -> Result<models::TvSeasonAggregateCredits200Response, Error<TvSeasonAggregateCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/aggregate_credits", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonAggregateCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonAggregateCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonAggregateCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the recent changes for a TV season.
pub async fn tv_season_changes_by_id(configuration: &configuration::Configuration, season_id: i32, end_date: Option<&str>, page: Option<i32>, start_date: Option<&str>) -> Result<models::TvSeasonChangesById200Response, Error<TvSeasonChangesByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_season_id = season_id;
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/tv/season/{season_id}/changes", configuration.base_path, season_id=p_season_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonChangesById200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonChangesById200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonChangesByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn tv_season_credits(configuration: &configuration::Configuration, series_id: i32, season_number: i32, language: Option<&str>) -> Result<models::TvSeasonCredits200Response, Error<TvSeasonCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/credits", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the details of a TV season.
pub async fn tv_season_details(configuration: &configuration::Configuration, series_id: i32, season_number: i32, append_to_response: Option<&str>, language: Option<&str>) -> Result<models::TvSeasonDetails200Response, Error<TvSeasonDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_append_to_response = append_to_response;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_append_to_response {
        req_builder = req_builder.query(&[("append_to_response", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of external IDs that have been added to a TV season.
pub async fn tv_season_external_ids(configuration: &configuration::Configuration, series_id: i32, season_number: i32) -> Result<models::TvSeasonExternalIds200Response, Error<TvSeasonExternalIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/external_ids", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonExternalIds200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonExternalIds200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonExternalIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the images that belong to a TV season.
pub async fn tv_season_images(configuration: &configuration::Configuration, series_id: i32, season_number: i32, include_image_language: Option<&str>, language: Option<&str>) -> Result<models::TvSeasonImages200Response, Error<TvSeasonImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_include_image_language = include_image_language;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/images", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_image_language {
        req_builder = req_builder.query(&[("include_image_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the translations for a TV season.
pub async fn tv_season_translations(configuration: &configuration::Configuration, series_id: i32, season_number: i32) -> Result<models::TvSeasonTranslations200Response, Error<TvSeasonTranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/translations", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonTranslations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonTranslations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the videos that belong to a TV season.
pub async fn tv_season_videos(configuration: &configuration::Configuration, series_id: i32, season_number: i32, include_video_language: Option<&str>, language: Option<&str>) -> Result<models::TvSeasonVideos200Response, Error<TvSeasonVideosError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_include_video_language = include_video_language;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/videos", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_video_language {
        req_builder = req_builder.query(&[("include_video_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonVideos200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonVideos200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonVideosError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of streaming providers we have for a TV season.
pub async fn tv_season_watch_providers(configuration: &configuration::Configuration, series_id: i32, season_number: i32, language: Option<&str>) -> Result<models::TvSeasonWatchProviders200Response, Error<TvSeasonWatchProvidersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_season_number = season_number;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/season/{season_number}/watch/providers", configuration.base_path, series_id=p_series_id, season_number=p_season_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeasonWatchProviders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeasonWatchProviders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeasonWatchProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the rating, watchlist and favourite status.
pub async fn tv_series_account_states(configuration: &configuration::Configuration, series_id: i32, session_id: Option<&str>, guest_session_id: Option<&str>) -> Result<models::MovieAccountStates200Response, Error<TvSeriesAccountStatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_session_id = session_id;
    let p_guest_session_id = guest_session_id;

    let uri_str = format!("{}/3/tv/{series_id}/account_states", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAccountStates200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAccountStates200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesAccountStatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate a TV show and save it to your rated list.
pub async fn tv_series_add_rating(configuration: &configuration::Configuration, series_id: i32, content_type: &str, guest_session_id: Option<&str>, session_id: Option<&str>, movie_add_rating_request: Option<models::MovieAddRatingRequest>) -> Result<models::MovieAddRating200Response, Error<TvSeriesAddRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_content_type = content_type;
    let p_guest_session_id = guest_session_id;
    let p_session_id = session_id;
    let p_movie_add_rating_request = movie_add_rating_request;

    let uri_str = format!("{}/3/tv/{series_id}/rating", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Content-Type", p_content_type.to_string());
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_movie_add_rating_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieAddRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieAddRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesAddRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the aggregate credits (cast and crew) that have been added to a TV show.
pub async fn tv_series_aggregate_credits(configuration: &configuration::Configuration, series_id: i32, language: Option<&str>) -> Result<models::TvSeriesAggregateCredits200Response, Error<TvSeriesAggregateCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/aggregate_credits", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesAggregateCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesAggregateCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesAggregateCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of TV shows airing today.
pub async fn tv_series_airing_today_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>, timezone: Option<&str>) -> Result<models::TvSeriesAiringTodayList200Response, Error<TvSeriesAiringTodayListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;
    let p_timezone = timezone;

    let uri_str = format!("{}/3/tv/airing_today", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesAiringTodayList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesAiringTodayList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesAiringTodayListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the alternative titles that have been added to a TV show.
pub async fn tv_series_alternative_titles(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesAlternativeTitles200Response, Error<TvSeriesAlternativeTitlesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/alternative_titles", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesAlternativeTitles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesAlternativeTitles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesAlternativeTitlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the recent changes for a TV show.
pub async fn tv_series_changes(configuration: &configuration::Configuration, series_id: i32, end_date: Option<&str>, page: Option<i32>, start_date: Option<&str>) -> Result<models::TvSeriesChanges200Response, Error<TvSeriesChangesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_end_date = end_date;
    let p_page = page;
    let p_start_date = start_date;

    let uri_str = format!("{}/3/tv/{series_id}/changes", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesChanges200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesChanges200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesChangesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the content ratings that have been added to a TV show.
pub async fn tv_series_content_ratings(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesContentRatings200Response, Error<TvSeriesContentRatingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/content_ratings", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesContentRatings200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesContentRatings200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesContentRatingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the latest season credits of a TV show.
pub async fn tv_series_credits(configuration: &configuration::Configuration, series_id: i32, language: Option<&str>) -> Result<models::TvSeriesCredits200Response, Error<TvSeriesCreditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/credits", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesCredits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesCredits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesCreditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn tv_series_delete_rating(configuration: &configuration::Configuration, series_id: i32, content_type: Option<&str>, guest_session_id: Option<&str>, session_id: Option<&str>) -> Result<models::MovieDeleteRating200Response, Error<TvSeriesDeleteRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_content_type = content_type;
    let p_guest_session_id = guest_session_id;
    let p_session_id = session_id;

    let uri_str = format!("{}/3/tv/{series_id}/rating", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_guest_session_id {
        req_builder = req_builder.query(&[("guest_session_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieDeleteRating200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieDeleteRating200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesDeleteRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a TV show.
pub async fn tv_series_details(configuration: &configuration::Configuration, series_id: i32, append_to_response: Option<&str>, language: Option<&str>) -> Result<models::TvSeriesDetails200Response, Error<TvSeriesDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_append_to_response = append_to_response;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_append_to_response {
        req_builder = req_builder.query(&[("append_to_response", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesDetails200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesDetails200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the episode groups that have been added to a TV show.
pub async fn tv_series_episode_groups(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesEpisodeGroups200Response, Error<TvSeriesEpisodeGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/episode_groups", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesEpisodeGroups200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesEpisodeGroups200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesEpisodeGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of external IDs that have been added to a TV show.
pub async fn tv_series_external_ids(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesExternalIds200Response, Error<TvSeriesExternalIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/external_ids", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesExternalIds200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesExternalIds200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesExternalIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the images that belong to a TV series.
pub async fn tv_series_images(configuration: &configuration::Configuration, series_id: i32, include_image_language: Option<&str>, language: Option<&str>) -> Result<models::MovieImages200Response, Error<TvSeriesImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_include_image_language = include_image_language;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/images", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_image_language {
        req_builder = req_builder.query(&[("include_image_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MovieImages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MovieImages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of keywords that have been added to a TV show.
pub async fn tv_series_keywords(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesKeywords200Response, Error<TvSeriesKeywordsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/keywords", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesKeywords200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesKeywords200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesKeywordsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the newest TV show ID.
pub async fn tv_series_latest_id(configuration: &configuration::Configuration, ) -> Result<models::TvSeriesLatestId200Response, Error<TvSeriesLatestIdError>> {

    let uri_str = format!("{}/3/tv/latest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesLatestId200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesLatestId200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesLatestIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of TV shows that air in the next 7 days.
pub async fn tv_series_on_the_air_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>, timezone: Option<&str>) -> Result<models::TvSeriesOnTheAirList200Response, Error<TvSeriesOnTheAirListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;
    let p_timezone = timezone;

    let uri_str = format!("{}/3/tv/on_the_air", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesOnTheAirList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesOnTheAirList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesOnTheAirListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of TV shows ordered by popularity.
pub async fn tv_series_popular_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>) -> Result<models::TvSeriesPopularList200Response, Error<TvSeriesPopularListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/tv/popular", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesPopularList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesPopularList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesPopularListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn tv_series_recommendations(configuration: &configuration::Configuration, series_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::TvSeriesRecommendations200Response, Error<TvSeriesRecommendationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/tv/{series_id}/recommendations", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesRecommendations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesRecommendations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesRecommendationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the reviews that have been added to a TV show.
pub async fn tv_series_reviews(configuration: &configuration::Configuration, series_id: i32, language: Option<&str>, page: Option<i32>) -> Result<models::TvSeriesReviews200Response, Error<TvSeriesReviewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/tv/{series_id}/reviews", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesReviews200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesReviews200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesReviewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the seasons and episodes that have screened theatrically.
pub async fn tv_series_screened_theatrically(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesScreenedTheatrically200Response, Error<TvSeriesScreenedTheatricallyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/screened_theatrically", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesScreenedTheatrically200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesScreenedTheatrically200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesScreenedTheatricallyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the similar TV shows.
pub async fn tv_series_similar(configuration: &configuration::Configuration, series_id: &str, language: Option<&str>, page: Option<i32>) -> Result<models::TvSeriesSimilar200Response, Error<TvSeriesSimilarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/tv/{series_id}/similar", configuration.base_path, series_id=crate::apis::urlencode(p_series_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesSimilar200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesSimilar200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesSimilarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of TV shows ordered by rating.
pub async fn tv_series_top_rated_list(configuration: &configuration::Configuration, language: Option<&str>, page: Option<i32>) -> Result<models::TvSeriesTopRatedList200Response, Error<TvSeriesTopRatedListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_page = page;

    let uri_str = format!("{}/3/tv/top_rated", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesTopRatedList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesTopRatedList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesTopRatedListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the translations that have been added to a TV show.
pub async fn tv_series_translations(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesTranslations200Response, Error<TvSeriesTranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/translations", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesTranslations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesTranslations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the videos that belong to a TV show.
pub async fn tv_series_videos(configuration: &configuration::Configuration, series_id: i32, include_video_language: Option<&str>, language: Option<&str>) -> Result<models::TvSeriesVideos200Response, Error<TvSeriesVideosError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;
    let p_include_video_language = include_video_language;
    let p_language = language;

    let uri_str = format!("{}/3/tv/{series_id}/videos", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_video_language {
        req_builder = req_builder.query(&[("include_video_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesVideos200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesVideos200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesVideosError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of streaming providers we have for a TV show.
pub async fn tv_series_watch_providers(configuration: &configuration::Configuration, series_id: i32) -> Result<models::TvSeriesWatchProviders200Response, Error<TvSeriesWatchProvidersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_series_id = series_id;

    let uri_str = format!("{}/3/tv/{series_id}/watch/providers", configuration.base_path, series_id=p_series_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TvSeriesWatchProviders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TvSeriesWatchProviders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TvSeriesWatchProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of streaming providers we have for TV shows.
pub async fn watch_provider_tv_list(configuration: &configuration::Configuration, language: Option<&str>, watch_region: Option<&str>) -> Result<models::WatchProvidersMovieList200Response, Error<WatchProviderTvListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_watch_region = watch_region;

    let uri_str = format!("{}/3/watch/providers/tv", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_watch_region {
        req_builder = req_builder.query(&[("watch_region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WatchProvidersMovieList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WatchProvidersMovieList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WatchProviderTvListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of the countries we have watch provider (OTT/streaming) data for.
pub async fn watch_providers_available_regions(configuration: &configuration::Configuration, language: Option<&str>) -> Result<models::WatchProvidersAvailableRegions200Response, Error<WatchProvidersAvailableRegionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;

    let uri_str = format!("{}/3/watch/providers/regions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WatchProvidersAvailableRegions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WatchProvidersAvailableRegions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WatchProvidersAvailableRegionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of streaming providers we have for movies.
pub async fn watch_providers_movie_list(configuration: &configuration::Configuration, language: Option<&str>, watch_region: Option<&str>) -> Result<models::WatchProvidersMovieList200Response, Error<WatchProvidersMovieListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_language = language;
    let p_watch_region = watch_region;

    let uri_str = format!("{}/3/watch/providers/movie", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_watch_region {
        req_builder = req_builder.query(&[("watch_region", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WatchProvidersMovieList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WatchProvidersMovieList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WatchProvidersMovieListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

